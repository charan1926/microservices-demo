pipeline {
  agent any

  options {
    timestamps()
    skipStagesAfterUnstable()
  }

  parameters {
    choice(
      name: 'TARGET_ENV',
      choices: ['dev', 'stage', 'prod'],
      description: 'Highest environment to deploy to'
    )
  }

  environment {
    APP_NAME   = "frontend"
    IMAGE_REPO = "boutique-frontend"
    TAG        = "build-${env.BUILD_NUMBER}"

    CLUSTER   = "kind"

    DEV_NS    = "boutique-dev"
    STAGE_NS  = "boutique-stage"
    PROD_NS   = "boutique-prod"

    KUBECONFIG = "/var/lib/jenkins/.kube/config"
  }

  stages {

    /* ========== BUILD & TEST ========== */

    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Build & Unit Test') {
      steps {
        sh '''
          cd src/frontend
          echo "TODO: run real tests here"
        '''
      }
    }

    /* ========== VAULT SECRETS ========== */

        stage('Fetch Secrets from Vault') {
      steps {
        withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
          sh '''
            echo "== Fetching secrets from Vault =="

            VAULT_ADDR="http://127.0.0.1:8200"
            SECRET_PATH="secret/data/dev/frontend"

            RESPONSE=$(curl -s \
              --header "X-Vault-Token: $VAULT_TOKEN" \
              --request GET \
              "$VAULT_ADDR/v1/$SECRET_PATH")

            echo "Raw Vault response from Vault:"
            echo "$RESPONSE"

            # Parse DB_USER and DB_PASSWORD without jq (simple sed-based extraction)
            DB_USER=$(printf '%s\n' "$RESPONSE" | sed -n 's/.*"DB_USER":"\\([^"]*\\)".*/\\1/p')
            DB_PASSWORD=$(printf '%s\n' "$RESPONSE" | sed -n 's/.*"DB_PASSWORD":"\\([^"]*\\)".*/\\1/p')

            if [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ]; then
              echo "Failed to parse DB_USER/DB_PASSWORD from Vault response"
              exit 1
            fi

            echo "DB_USER from Vault: $DB_USER"
            echo "DB_PASSWORD loaded (hidden)"

            echo "DB_USER=$DB_USER"        >  vault_env.sh
            echo "DB_PASSWORD=$DB_PASSWORD" >> vault_env.sh
          '''
          script {
            def props = readProperties file: 'vault_env.sh'
            env.DB_USER = props['DB_USER']
            env.DB_PASSWORD = props['DB_PASSWORD']
          }
        }
      }
    }
    /* ========== DOCKER BUILD & TRIVY ========== */

    stage('Docker Build') {
      steps {
        sh '''
          cd src/frontend
          docker build -t ${IMAGE_REPO}:${TAG} .
        '''
      }
    }

    stage('Trivy Scan') {
      steps {
        sh '''
          echo "== Trivy Scan Stage via Docker =="

          docker ps >/dev/null 2>&1 || {
            echo "Docker not accessible from Jenkins. Skipping Trivy scan."
            exit 0
          }

          echo "Pulling Trivy image..."
          docker pull aquasec/trivy:latest || {
            echo "Failed to pull Trivy image. Skipping scan."
            exit 0
          }

          echo "Running Trivy image scan on ${IMAGE_REPO}:${TAG} ..."
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
              --exit-code 0 \
              --severity HIGH,CRITICAL \
              ${IMAGE_REPO}:${TAG} || true
        '''
      }
    }

    stage('Load Image into kind') {
      steps {
        sh '''
          kind load docker-image ${IMAGE_REPO}:${TAG} --name ${CLUSTER}
        '''
      }
    }

    /* ========== DEPLOY TO DEV ========== */

    stage('Deploy to DEV') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'dev' }
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        sh '''
          echo "Using DB_USER from Vault in deploy stage: ${DB_USER}"
          echo "Deploying ${IMAGE_REPO}:${TAG} to DEV (${DEV_NS}) ..."
          kubectl -n ${DEV_NS} set image deployment/${APP_NAME} \
            server=${IMAGE_REPO}:${TAG}
          kubectl -n ${DEV_NS} rollout status deployment/${APP_NAME}
        '''
      }
    }

    stage('Smoke Test DEV') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'dev' }
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        sh '''
          echo "TODO: implement real dev smoke tests (curl health endpoints, etc.)"
        '''
      }
    }

    /* ========== PROMOTE TO STAGE ========== */

    stage('Approve Promotion to STAGE') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        script {
          input message: "Promote image ${IMAGE_REPO}:${TAG} to STAGE?", ok: "Promote"
        }
      }
    }

    stage('Deploy to STAGE') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        sh '''
          echo "Deploying ${IMAGE_REPO}:${TAG} to STAGE (${STAGE_NS}) ..."
          kubectl -n ${STAGE_NS} set image deployment/${APP_NAME} \
            server=${IMAGE_REPO}:${TAG}
          kubectl -n ${STAGE_NS} rollout status deployment/${APP_NAME}
        '''
      }
    }

    stage('Smoke Test STAGE') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        sh '''
          echo "TODO: implement real stage smoke tests"
        '''
      }
    }

    /* ========== PROMOTE TO PROD ========== */

    stage('Approve Promotion to PROD') {
      when {
        expression { params.TARGET_ENV == 'prod' }
      }
      steps {
        script {
          input message: "Promote image ${IMAGE_REPO}:${TAG} to PROD?", ok: "Promote"
        }
      }
    }

    stage('Deploy to PROD') {
      when {
        expression { params.TARGET_ENV == 'prod' }
      }
      steps {
        sh '''
          echo "Deploying ${IMAGE_REPO}:${TAG} to PROD (${PROD_NS}) ..."
          kubectl -n ${PROD_NS} set image deployment/${APP_NAME} \
            server=${IMAGE_REPO}:${TAG}
          kubectl -n ${PROD_NS} rollout status deployment/${APP_NAME}
        '''
      }
    }

    stage('Smoke Test PROD') {
      when {
        expression { params.TARGET_ENV == 'prod' }
      }
      steps {
        sh '''
          echo "TODO: implement real prod smoke tests"
        '''
      }
    }
  }
}
