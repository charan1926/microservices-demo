pipeline {
  agent any

  options {
    timestamps()
    skipStagesAfterUnstable()
  }

  parameters {
    choice(
      name: 'TARGET_ENV',
      choices: ['dev', 'stage', 'prod'],
      description: 'Highest environment to deploy to'
    )
  }

  environment {
    APP_NAME   = "frontend"
    IMAGE_REPO = "boutique-frontend"
    TAG        = "build-${env.BUILD_NUMBER}"

    CLUSTER   = "kind"

    DEV_NS    = "boutique-dev"
    STAGE_NS  = "boutique-stage"
    PROD_NS   = "boutique-prod"

    KUBECONFIG = "/var/lib/jenkins/.kube/config"

    # Git identity used by Jenkins to commit manifest changes
    GIT_COMMIT_USER = "jenkins-cd"
    GIT_COMMIT_EMAIL = "jenkins@example.com"

    # relative path where k8s manifests live in repo
    MANIFEST_DIR = "kubernetes-manifests"
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Build & Unit Test') {
      steps {
        sh '''
          cd src/frontend
          echo "TODO: run real tests here"
        '''
      }
    }

    stage('Fetch Secrets from Vault') {
      steps {
        catchError(buildResult: 'SUCCESS', stageResult: 'SUCCESS') {
          withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
            sh '''
              echo "== Fetching secrets from Vault =="
              VAULT_ADDR="http://127.0.0.1:8200"
              SECRET_PATH="secret/data/dev/frontend"

              RESPONSE=$(curl -s \
                --header "X-Vault-Token: $VAULT_TOKEN" \
                --request GET \
                "$VAULT_ADDR/v1/$SECRET_PATH")

              echo "Raw Vault response from Vault:"
              echo "$RESPONSE"

              DB_USER=$(printf '%s\n' "$RESPONSE" | sed -n 's/.*"DB_USER":"\\([^"]*\\)".*/\\1/p')
              DB_PASSWORD=$(printf '%s\n' "$RESPONSE" | sed -n 's/.*"DB_PASSWORD":"\\([^"]*\\)".*/\\1/p')

              if [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ]; then
                echo "WARNING: Failed to parse DB_USER/DB_PASSWORD from Vault response. Continuing anyway."
              else
                echo "DB_USER from Vault: $DB_USER"
                echo "DB_PASSWORD loaded (hidden)"
              fi

              { echo "DB_USER=${DB_USER}"; echo "DB_PASSWORD=${DB_PASSWORD}"; } > vault_env.sh || true
            '''
            script {
              def props = readProperties file: 'vault_env.sh'
              env.DB_USER = props['DB_USER']
              env.DB_PASSWORD = props['DB_PASSWORD']
            }
          }
        }
      }
    }

    stage('Docker Build') {
      steps {
        sh '''
          cd src/frontend
          docker build -t ${IMAGE_REPO}:${TAG} .
        '''
      }
    }

    stage('Trivy Scan') {
      steps {
        sh '''
          echo "== Trivy Scan Stage via Docker =="
          docker ps >/dev/null 2>&1 || { echo "Docker not accessible from Jenkins. Skipping Trivy scan."; exit 0; }
          docker pull aquasec/trivy:latest || { echo "Failed to pull Trivy image. Skipping scan."; exit 0; }
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --exit-code 0 --severity HIGH,CRITICAL ${IMAGE_REPO}:${TAG} || true
        '''
      }
    }

    stage('Load Image into kind') {
      steps {
        sh '''
          kind load docker-image ${IMAGE_REPO}:${TAG} --name ${CLUSTER}
        '''
      }
    }

    /* ========== PROMOTE BY COMMITTING MANIFEST → Argo CD will deploy ========== */

    stage('Promote: update manifest in git (Dev/Stage/Prod)') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'dev' }
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        withCredentials([usernamePassword(credentialsId: 'git-credentials', passwordVariable: 'GIT_PASS', usernameVariable: 'GIT_USER')]) {
          sh '''
            set -e
            echo "Promoting image ${IMAGE_REPO}:${TAG} for TARGET_ENV=${TARGET_ENV}"

            # configure git identity
            git config user.email "${GIT_COMMIT_EMAIL}"
            git config user.name "${GIT_COMMIT_USER}"

            # Ensure we have a clean workspace and the latest main
            git checkout main || true
            git pull origin main || true

            # Find YAML files under MANIFEST_DIR that mention boutique-frontend and update their image lines.
            # This is intentionally broad — it updates any image lines referencing boutique-frontend.
            FOUND=0
            if [ -d "${MANIFEST_DIR}" ]; then
              FILES=$(find ${MANIFEST_DIR} -type f \( -name "*.yaml" -o -name "*.yml" \) -print)
              for f in $FILES; do
                if grep -q "boutique-frontend" "$f"; then
                  echo "Updating image in $f"
                  # replace any existing boutique-frontend image with the new tag
                  sed -i -E "s|(image:[[:space:]]*).*boutique-frontend:[^[:space:]]*|\\1 ${IMAGE_REPO}:${TAG}|g" "$f" || true
                  FOUND=1
                fi
              done
            fi

            # Fallback: update any image lines in repo if MANIFEST_DIR not used
            if [ "$FOUND" -eq 0 ]; then
              echo "No files under ${MANIFEST_DIR} referenced boutique-frontend; attempting repository-wide replace"
              FILES=$(git ls-files '*.yaml' '*.yml' || true)
              for f in $FILES; do
                if grep -q "boutique-frontend" "$f"; then
                  echo "Updating image in $f"
                  sed -i -E "s|(image:[[:space:]]*).*boutique-frontend:[^[:space:]]*|\\1 ${IMAGE_REPO}:${TAG}|g" "$f" || true
                  FOUND=1
                fi
              done
            fi

            if [ "$FOUND" -eq 0 ]; then
              echo "WARNING: No manifest updated (no file contained 'boutique-frontend')."
            else
              git add -A
              # Only commit if there are changes
              if git diff --cached --quiet; then
                echo "No manifest changes to commit."
              else
                git commit -m "ci: promote ${IMAGE_REPO}:${TAG} [ci skip]" || true
                # Push using provided credentials (supports HTTPS push)
                # Configure remote to include credentials if needed
                ORIGIN_URL=$(git config --get remote.origin.url || echo "")
                if echo "$ORIGIN_URL" | grep -q "https://"; then
                  # embed credentials for push
                  PROTO=$(echo "$ORIGIN_URL" | sed -E 's#(https://).*#\\1#')
                  REMAINDER=$(echo "$ORIGIN_URL" | sed -E 's#https://##')
                  AUTH_URL="https://${GIT_USER}:${GIT_PASS}@${REMAINDER}"
                  git push "$AUTH_URL" HEAD:main || { echo "git push via auth-url failed; trying regular git push"; git push origin HEAD:main || true; }
                else
                  # SSH or other remote - attempt normal push (assumes Jenkins has keys)
                  git push origin HEAD:main || true
                fi
              fi
            fi

            # Wait for ArgoCD to sync (only if argocd is installed and app exists)
            # Map TARGET_ENV to argocd app name
            APP_NAME="boutique-${TARGET_ENV}"
            echo "Waiting for ArgoCD app ${APP_NAME} to become Synced+Healthy (timeout 180s)..."
            T=0
            until [ $T -ge 180 ]; do
              SYNC=$(kubectl -n argocd get application ${APP_NAME} -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Missing")
              HEALTH=$(kubectl -n argocd get application ${APP_NAME} -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Missing")
              echo "ArgoCD status: sync=${SYNC} health=${HEALTH}"
              if [ "$SYNC" = "Synced" ] && [ "$HEALTH" = "Healthy" ]; then
                echo "ArgoCD app ${APP_NAME} is Synced and Healthy"
                break
              fi
              sleep 5
              T=$((T+5))
            done

            if [ $T -ge 180 ]; then
              echo "Timeout waiting for ArgoCD app ${APP_NAME} to sync. Check ArgoCD UI for details."
            fi
          '''
        }
      }
    }

    stage('Smoke Test DEV') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'dev' }
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        sh '''
          echo "TODO: implement real dev smoke tests (curl health endpoints, etc.)"
        '''
      }
    }

    stage('Approve Promotion to STAGE') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        script {
          input message: "Promote image ${IMAGE_REPO}:${TAG} to STAGE?", ok: "Promote"
        }
      }
    }

    stage('Smoke Test STAGE') {
      when {
        anyOf {
          expression { params.TARGET_ENV == 'stage' }
          expression { params.TARGET_ENV == 'prod' }
        }
      }
      steps {
        sh '''
          echo "TODO: implement real stage smoke tests"
        '''
      }
    }

    stage('Approve Promotion to PROD') {
      when {
        expression { params.TARGET_ENV == 'prod' }
      }
      steps {
        script {
          input message: "Promote image ${IMAGE_REPO}:${TAG} to PROD?", ok: "Promote"
        }
      }
    }

    stage('Smoke Test PROD') {
      when {
        expression { params.TARGET_ENV == 'prod' }
      }
      steps {
        sh '''
          echo "TODO: implement real prod smoke tests"
        '''
      }
    }
  }
}
